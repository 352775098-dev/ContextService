# ContextService
上下文工程实现

# 上下文工程解决的问题场景
- **上下文窗口限制**：LLM的上下文窗口有限，需要对历史对话进行智能压缩
- **上下文持久化**：将对话历史保存到持久化存储，支持跨会话恢复
- **上下文选择**：从海量历史中选择最相关的上下文片段
- **工具编排**：管理对话中的工具调用链和状态
- **长期记忆**：实现跨会话的信息保留和检索
1. Agent内部的上下文整合：时间推理、内容整合、冲突更新、记忆召回、工具输出信息整合
2. 跨Agent的上下文共享和隔离
3. 跨端的agent上下文共享和隔离

# 上下文工程设计原则
1. 所有模型调用前都应该有上下文，prompt动态调整也在上下文范围，对于不需要上下文内容的经过上下文调用后可以不填内容
2. 写原始对话应放到记忆服务，写对话的时机应由对话系统负责；上下文维护的是会话的记忆、摘要、工具的输出、 不是原始对话
3. 对模型固定配一个上下文窗口，每个模型的上下文窗口隔离；窗口中动态内容持续刷新，
4. 把上下文成消费者和生产者模式，填充上下文的过程和Agent的流程异步，业务路径不允许随意加流程
5. 尽量不要搞显性调用，建议用消息或事件方式作为接口
6. 上下文应该做成模型感知的，场景的诉求通过prompt模板和skill来实现，要用开放算法机制，针对不同场景，去动态调整


# 上下文工程的逻辑架构
以下是将原图内容转换为 Markdown 表格形式的“上下文工程”架构说明，适合在 Markdown 编辑器中直接使用：

# 上下文工程架构

## 分层架构概览

| 层级 | 组件 |
|------|------|
| **接口层** | 写入QA · 查询上下文 · 重建上下文 · 删除上下文 |
| **上下文管理层** | 保存 · 压缩 · 老化 · 关联 · 记忆 · 组装 · 结构化模板 |
| **上下文数据层** | 私有上下文 · 公共上下文 · 原始对话 · 压缩内容 · 长期记忆 · 工具结果 |
| **基础组件层** | RAG · 长期记忆 · 工具 · 模型推理 |

---

## 详细说明

### 📥 接口层
对外提供的操作入口：
- 写入QA
- 查询上下文
- 重建上下文
- 删除上下文

### ⚙️ 上下文管理层
核心处理逻辑：
- 保存
- 压缩
- 老化
- 关联
- 记忆
- 组装
- 结构化模板

### 📦 上下文数据层
存储的数据类型：
- 私有上下文
- 公共上下文
- 原始对话
- 压缩内容
- 长期记忆
- 工具结果

### 🧩 基础组件层
底层支撑能力：
- RAG
- 长期记忆
- 工具
- 模型推理

## 数据流示意（文本描述）
1. 接口层接收请求 → 调用管理层对应功能
2. 管理层处理数据 → 读写数据层
3. 数据层依赖基础组件层实现具体能力
4. 基础组件层提供推理、检索、工具调用等能力

# 上下文工程实现
1. 上下文工程实现为一个服务形态，开发语言为Go语言
2. 上下文工程服务内部只做调度和管理，不做场景化的数据处理（如场景化的压缩、场景化的记忆召回）
3. 原始对话内容写入直接写入到长期记忆服务KMM中，不经过上下文工程服务
4. 长期记忆服务在收到原始对话写入后，通知上下文工程服务，由上下文工程服务来触发上下文内容的管理
5. 上下文工程服务接收到新的原始对话更新通知消息后，根据当前写入的agent，拉取该agent的任务流中的模型调用流程，触发长期记忆执行该agent所需的压缩流程，并为该任务；流中所有的涉及到的给模型填充上下文的地方来提前准备上下文，且提前召回记忆，根据用户的query提前查找相关联的历史对话
6. 业务agent在调用模型时必然通过钩子或事件来串行获取上下文填充prompt，上下文工程负责填充prompt中动态内容部分，如果存在上下文内容中的某一部分内容还未填充，则需串行等待上下文工程服务填充好对应的上下文才能继续往下执行；如果已经填充好或者部分非必须的内容未填充好则直接往下执行

7. 上下文实例按照user+session+query粒度创建，session与上下文实例是1：N关系，上下文实例与AgentGraph是1:1关系
8. SessionContext（历史对话）按user+session粒度存储上下文；长期记忆Context和工具Context按user+session+query粒度存储上下文；Prompt（AgentFlow）无user和session，静态存储
9. 记忆召回具有agent业务属性，需按照业务场景来进行查询改写后召回记忆，该流程在KMM中实现（建议使用低码化）
10. 在新query进来后就创建上下文实例

