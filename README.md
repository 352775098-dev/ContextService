# ContextService
上下文工程实现

# 上下文工程解决的问题场景
- **上下文窗口限制**：LLM的上下文窗口有限，需要对历史对话进行智能压缩
- **上下文持久化**：将对话历史保存到持久化存储，支持跨会话恢复
- **上下文选择**：从海量历史中选择最相关的上下文片段
- **工具编排**：管理对话中的工具调用链和状态
- **长期记忆**：实现跨会话的信息保留和检索
1. Agent内部的上下文整合：时间推理、内容整合、冲突更新、记忆召回、工具输出信息整合
2. 跨Agent的上下文共享和隔离
3. 跨端的agent上下文共享和隔离

# 上下文工程设计原则
1. 所有模型调用前都应该有上下文，prompt动态调整也在上下文范围，对于不需要上下文内容的经过上下文调用后可以不填内容
2. 写原始对话应放到记忆服务，写对话的时机应由对话系统负责；上下文维护的是会话的记忆、摘要、工具的输出、 不是原始对话
3. 对模型固定配一个上下文窗口，每个模型的上下文窗口隔离；窗口中动态内容持续刷新，
4. 把上下文成消费者和生产者模式，填充上下文的过程和Agent的流程异步，业务路径不允许随意加流程
5. 尽量不要搞显性调用，建议用消息或事件方式作为接口
6. 上下文应该做成模型感知的，场景的诉求通过prompt模板和skill来实现，要用开放算法机制，针对不同场景，去动态调整


# 上下文工程的逻辑架构
以下是将原图内容转换为 Markdown 表格形式的“上下文工程”架构说明，适合在 Markdown 编辑器中直接使用：

# 上下文工程架构

## 分层架构概览

| 层级 | 组件 |
|------|------|
| **接口层** | 写入QA · 查询上下文 · 重建上下文 · 删除上下文 |
| **上下文管理层** | 保存 · 压缩 · 老化 · 关联 · 记忆 · 组装 · 结构化模板 |
| **上下文数据层** | 私有上下文 · 公共上下文 · 原始对话 · 压缩内容 · 长期记忆 · 工具结果 |
| **基础组件层** | RAG · 长期记忆 · 工具 · 模型推理 |

---

## 详细说明

### 📥 接口层
对外提供的操作入口：
- 写入QA
- 查询上下文
- 重建上下文
- 删除上下文

### ⚙️ 上下文管理层
核心处理逻辑：
- 保存
- 压缩
- 老化
- 关联
- 记忆
- 组装
- 结构化模板

### 📦 上下文数据层
存储的数据类型：
- 私有上下文
- 公共上下文
- 原始对话
- 压缩内容
- 长期记忆
- 工具结果

### 🧩 基础组件层
底层支撑能力：
- RAG
- 长期记忆
- 工具
- 模型推理

---

## 数据流示意（文本描述）

1. 接口层接收请求 → 调用管理层对应功能
2. 管理层处理数据 → 读写数据层
3. 数据层依赖基础组件层实现具体能力
4. 基础组件层提供推理、检索、工具调用等能力

您可以直接将此内容复制到任何 Markdown 编辑器中使用。如需添加更复杂的格式（如 Mermaid 图表），我也可以为您生成对应的代码。
